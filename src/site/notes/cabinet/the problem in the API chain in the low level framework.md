---
{"dg-publish":true,"permalink":"/cabinet/the problem in the API chain in the low level framework/"}
---

## Today’s Post: A Niche Problem That Arrived Late in Tech

Today, we’re exploring a niche but critical issue that often goes unnoticed until it’s too late:  
**Low-level APIs affecting high-level products.**

We’ll look at:

- Why thinking only in high-level languages can be limiting
- How low-level systems still shape modern software
- Whether the solution is to return to low-level thinking or adopt a new mindset

This post offers a bird’s-eye view—no deep dives, just big-picture thinking.

---

## Setting the Stage

Imagine you're working on a piece of software. It’s defined by multiple teams—backend, frontend, and all the layers in between. Now, this software is built on an old GUI framework, which itself was built on an even older GUI from the 1990s. The OS has changed. The frameworks have evolved. But the core building blocks? Still stuck in the '90s.

Here’s the problem:  
The issue is so deeply embedded in this legacy system that the only way to fix it is to rebuild the framework and create new building blocks. That’s doable. The real challenge? You don’t have the people who know how to do it.

High-level software still needs low-level code. Why?  
Because even in today, AI and vibe coding world, apps still run on the same old foundations of: binary, hexadecimal, memory, and drivers. building on top of an foundation can lead to a lot of problems down the line in regard of optimization and migration to new platform.

---

## High-Level Leaves You at Bird’s-Eye View

Even modern high-level languages like Python, JavaScript, and Rust are built on lower-level languages like C, Java, and COBOL.

Back in the day, C was considered high-level because it was the closest we had to writing in English. Before that, we had binary, assembly, and punch cards—essentially recording button presses on old computer dashboards.

Then came [C](https://en.wikipedia.org/wiki/C_\(programming_language\)), preceded by [B](https://en.wikipedia.org/wiki/B_\(programming_language\)) and [COBOL](https://en.wikipedia.org/wiki/COBOL)[^1]. These languages were closer to human language but still operated within the logic of machines. After that came Python, JavaScript, and others—more forgiving, more expressive, and more human-friendly.

---

## The Problem

Even if we only see the steering wheel, shifter, dashboard, and windshield, there are still problems under the hood that require a deep dive into the grease and bolts.

The language may have changed—especially with the rise of AI and “vibe coding”—but the code still runs on the same old chips, with the same old transistors, and the same old assembly instructions feeding into the ALU. (At least until quantum computing becomes mainstream.)

This creates a gap between what developers _think_ the code does and what it _actually_ does.  
On a daily basis, it’s not a big deal. That’s why we rarely hear about it.  
But every now and then—through hacks, OS builds, AI optimization, or hardware acceleration—low-level mastery leads to major breakthroughs.

We forget that there are still coders working in the shadows, making the world run bit by bit.

---

## Can We Stop the Madness?

I wouldn’t call it madness—more like a massive knowledge gap.  
And no, it won’t stop. It’ll only grow.

The only way to bridge the gap is to update the old code.  
Software still running on C and COBOL needs a modern treatment.  
New tools must replace the old ones.  
And most importantly, people need to stop treating low-level languages like an insult.

They’re not “low.”  
They’re **in-depth**.

> [!info]  
> The real reason I wrote this post is because of this [video](https://www.youtube.com/watch?v=p7L8xqKzmP8) and the [2024 CrowdStrike-related IT outages](https://en.wikipedia.org/wiki/2024_CrowdStrike-related_IT_outages)

[[cabinet/welcome_to_my_garden\|back to the web hub]] 🏡

---

[^1]:COBOL – 1959 (Common Business-Oriented Language)  
B – 1969  
C – 1972  
Assembly – 1947 
